[{"content":"意图 中介者模式是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。\n假定一组对象存在依赖关系,如果每个对象显式的存储另外几个对象的引用，那么对象的依赖关系就会变得杂乱无章\nflowchart LR; A \u003c--\u003e B F \u003c--\u003e B A \u003c--\u003e E A \u003c--\u003e B D \u003c--\u003e E D \u003c--\u003e F B \u003c--\u003e C C \u003c--\u003e D 如果我们引入一个交换机作为他们之间通信的中介者那么他们之间的耦合就能变得松散\nflowchart 交换机\u003c--\u003e A 交换机\u003c--\u003e B 交换机\u003c--\u003e C 交换机\u003c--\u003e D 交换机\u003c--\u003e E 交换机\u003c--\u003e F 类图 classDiagram class Mediator \u0026lt;\u0026lt;inteface\u0026gt;\u0026gt; Mediator class Colleague \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; Colleague Mediator \u003c-- Colleague :mediator ConcreteMediator ..|\u003e Mediator ConcreteColleagueA --|\u003e Colleague ConcreteColleagueB --|\u003e Colleague ConcreteMediator --\u003e ConcreteColleagueA ConcreteMediator --\u003e ConcreteColleagueB 同事 （Colleague） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。\n中介者 （Mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。\n具体中介者 （Concrete Mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。\n组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。\n对于组件来说， 中介者看上去完全就是一个黑箱。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。\nc++实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; typedef string Request; class Colleague; class Mediator { public: virtual void notify(Colleague *sender, Request request) = 0; }; class Colleague { public: Colleague(Mediator *mediator = nullptr) : mediator(mediator) {} void set_mediator(Mediator *mediator) { this-\u0026gt;mediator = mediator; } protected: Mediator *mediator; }; class Counter : public Colleague { public: Counter(Mediator *mediator = nullptr) : Colleague(mediator) {} void order_dishes() { cout \u0026lt;\u0026lt; \u0026#34;Counter: Order dishes\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Counter: Send request to the kitchen\u0026#34; \u0026lt;\u0026lt; endl; if (mediator != nullptr) { mediator-\u0026gt;notify(this, \u0026#34;pass the order to the kitchen\u0026#34;); } } }; class Cook : public Colleague { public: Cook(Mediator *mediator = nullptr) : Colleague(mediator) {} void cook_dishes() { cout \u0026lt;\u0026lt; \u0026#34;Cook: Cooking dishes\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Cook: Dishes are ready\u0026#34; \u0026lt;\u0026lt; endl; if (mediator != nullptr) { mediator-\u0026gt;notify(this, \u0026#34;dishes are ready\u0026#34;); } } }; class Waiter : public Colleague { public: Waiter(Mediator *mediator = nullptr) : Colleague(mediator) {} void serve_dishes() { cout \u0026lt;\u0026lt; \u0026#34;Waiter: Serve dishes\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Waiter: Send request to the consumer\u0026#34; \u0026lt;\u0026lt; endl; if (mediator != nullptr) { mediator-\u0026gt;notify(this, \u0026#34;pass the order to the consumer\u0026#34;); } } }; class Consumer : public Colleague { public: Consumer(Mediator *mediator = nullptr) : Colleague(mediator) {} void eat_dishes() { cout \u0026lt;\u0026lt; \u0026#34;Consumer: Eat dishes\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Consumer: The dishes are good!\u0026#34; \u0026lt;\u0026lt; endl; } }; class Scheduler : public Mediator { private: Counter *counter; Cook *cook; Waiter *waiter; Consumer *consumer; public: Scheduler(Counter *counter, Cook *cook, Waiter *waiter, Consumer *consumer) : counter(counter), cook(cook), waiter(waiter), consumer(consumer) { counter-\u0026gt;set_mediator(this); cook-\u0026gt;set_mediator(this); waiter-\u0026gt;set_mediator(this); consumer-\u0026gt;set_mediator(this); } void notify(Colleague *sender, Request request) override { if (request == \u0026#34;pass the order to the kitchen\u0026#34;) { cook-\u0026gt;cook_dishes(); } else if (request == \u0026#34;dishes are ready\u0026#34;) { waiter-\u0026gt;serve_dWishes(); } else if (request == \u0026#34;pass the order to the consumer\u0026#34;) { consumer-\u0026gt;eat_dishes(); } } }; void client() { Counter *counter = new Counter(); Cook *cook = new Cook(); Waiter *waiter = new Waiter(); Consumer *consumer = new Consumer(); Scheduler *scheduler = new Scheduler(counter, cook, waiter, consumer); counter-\u0026gt;order_dishes(); } int main() { client(); return 0; } 适用性 当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。\n该模式让你将对象间的所有关系抽取成为一个单独的类， 以使对于特定组件的修改工作独立于其他组件。\n当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。\n应用中介者模式后， 每个组件不再知晓其他组件的情况。 尽管这些组件无法直接交流， 但它们仍可通过中介者对象进行间接交流。 如果你希望在不同应用中复用一个组件， 则需要为其提供一个新的中介者类。\n如果为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式。\n由于所有组件间关系都被包含在中介者中， 因此你无需修改组件就能方便地新建中介者类以定义新的组件合作方式。\n效果 单一职责原则。 你可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护。\n开闭原则。 你无需修改实际组件就能增加新的中介者。\n你可以减轻应用中多个组件间的耦合情况。\n你可以更方便地复用各个组件。\n一段时间后， 中介者可能会演化成为上帝对象。\n与其他模式的关系 责任链模式用于处理请求发送者和接收者之间的不同连接方式：\n责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。 命令在发送者和请求者之间建立单向连接。 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。 观察者允许接收者动态地订阅或取消接收请求。 外观模式的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。\n外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。 中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。 中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。\n中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。\n有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。\n当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。\n假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。\n","date":"2023-01-18T00:00:00Z","permalink":"https://moefulye.github.io/p/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/","title":"中介者模式"},{"content":"定义 类图 classDiagram class Originator { -data +save()Memento +restore(m: Memento) } note for Memento \"Memento的方法只对Originator对象开放\" class Memento{ -constructor(data) -getState() -data } Originator ..\u003e Memento note for CareTaker \"doSomething(){\\n m=state.save()\\nhistory.push(m) \\n//do_something\\n}\" note for CareTaker \"undo(){\\nm=history.pop()\\nstate.restore(m)\\n}\" class CareTaker{ -state: originator -history: Stack~Memento~ +doSomething() +undo() } CareTaker o--\u003e Memento :memnto CareTaker o--\u003e Originator :state 原发器 （Originator） 类可以生成自身状态的快照， 也可以在需要时通过快照恢复自身状态。\n备忘录 （Memento） 是原发器状态快照的值对象 （value object）。 通常做法是将备忘录设为不可变的， 并通过构造函数一次性传递数据。\n负责人 （Caretaker） 仅知道 “何时” 和 “为何” 捕捉原发器的状态， 以及何时恢复状态。 负责人通过保存备忘录栈来记录原发器的历史状态。 当原发器需要回溯历史状态时， 负责人将从栈中获取最顶部的备忘录， 并将其传递给原发器的恢复 （restoration） 方法。\n在该实现方法中， 备忘录类将被嵌套在原发器中。 这样原发器就可访问备忘录的成员变量和方法， 即使这些方法被声明为私有。 另一方面， 负责人对于备忘录的成员变量和方法的访问权限非常有限： 它们只能在栈中保存备忘录， 而不能修改其状态。\n适用性 当你需要创建对象状态快照来恢复其之前的状态时， 可以使用备忘录模式。\n备忘录模式允许你复制对象中的全部状态 （包括私有成员变量）， 并将其独立于对象进行保存。 尽管大部分人因为 “撤销” 这个用例才记得该模式， 但其实它在处理事务 （比如需要在出现错误时回滚一个操作） 的过程中也必不可少。\n当直接访问对象的成员变量、 获取器或设置器将导致封装被突破时， 可以使用该模式。\n备忘录让对象自行负责创建其状态的快照。 任何其他对象都不能读取快照， 这有效地保障了数据的安全性。\n效果 你可以在不破坏对象封装情况的前提下创建对象状态快照。\n你可以通过让负责人维护原发器状态历史记录来简化原发器代码。\n如果客户端过于频繁地创建备忘录， 程序将消耗大量内存。\n负责人必须完整跟踪原发器的生命周期， 这样才能销毁弃用的备忘录。\n绝大部分动态编程语言 （例如 PHP、 Python 和 JavaScript） 不能确保备忘录中的状态不被修改\n例子 你可以同时使用命令模式和备忘录模式来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。\n你可以同时使用备忘录和迭代器模式来获取当前迭代器的状态， 并且在需要的时候进行回滚。\n有时候原型模式可以作为备忘录的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建\n","date":"2023-01-18T00:00:00Z","permalink":"https://moefulye.github.io/p/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","title":"备忘录模式"},{"content":"定义 把某些方法的实现延迟到子类\n类图 classDiagram c++实现 适用性 效果 例子 ","date":"2023-01-18T00:00:00Z","permalink":"https://moefulye.github.io/p/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/","title":"模板方法"},{"content":"定义 状态机\n类图 classDiagram c++实现 适用性 效果 例子 ","date":"2023-01-18T00:00:00Z","permalink":"https://moefulye.github.io/p/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","title":"状态模式"},{"content":"定义 传闭包函数\n类图 classDiagram c++实现 适用性 效果 例子 ","date":"2023-01-18T00:00:00Z","permalink":"https://moefulye.github.io/p/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","title":"策略模式"},{"content":"定义 观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。\nflowchart TD; publisher --\"更改通知\"--\u003e subcriberA publisher --\"更改通知\"--\u003e subcriberB publisher --\"更改通知\"--\u003e subcriberC subcriberA -.\"查询、更新\".-\u003e publisher subcriberB -.\"查询、更新\".-\u003e publisher subcriberC -.\"查询、更新\".-\u003e publisher 类图 classDiagram class Publisher{ -subscribers :Collection~Subcriber~ -state +getState() +attach(newSubcriber) +detach(newSubcriber) +notify() } class Subcriber{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +update()* } class ConcreteSubcriberA{ -publisher -state +update() } class ConcreteSubcriberB{ -publisher -state +update() } ConcreteSubcriberA ..|\u003e Subcriber ConcreteSubcriberB ..|\u003e Subcriber ConcreteSubcriberA o--\u003e Publisher :publisher ConcreteSubcriberB o--\u003e Publisher :publisher c++实现 适用性 效果 例子 ","date":"2023-01-18T00:00:00Z","permalink":"https://moefulye.github.io/p/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","title":"观察者模式"},{"content":"定义 解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。\n类图 classDiagram Client --\u003e Context Client --\u003e Expression class Expression{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +interpret(context)* } class TerminalExpression{ +interpret(context) } class NonterminalExpression{ +interpret(context) } TerminalExpression ..|\u003e Expression NonterminalExpression ..|\u003e Expression NonterminalExpression o--\u003e Expression 例子 编译器、规则引擎、正则表达式\n","date":"2023-01-18T00:00:00Z","permalink":"https://moefulye.github.io/p/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","title":"解释器模式"},{"content":"定义 访问者模式是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。\n双分派\n类图 classDiagram c++实现 适用性 效果 例子 ","date":"2023-01-18T00:00:00Z","permalink":"https://moefulye.github.io/p/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","title":"访问者模式"},{"content":"定义 迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。\n问题 只读迭代器 支持增删改?在增删改等写操作后迭代器是否会失效？怎么实现一个健壮的迭代器？ 空迭代器 内部迭代器、外部迭代器 支持双向移动随机移动？ 在同一个集合上多个迭代器并行迭代? 类图 classDiagram class Iterator~T~ { \u0026lt\u0026ltinterface\u0026gt\u0026gt +hasNext()*bool +curruent()*T +next()* } class Collection~T~ { \u0026lt\u0026ltinterface\u0026gt\u0026gt +iter()*Iterator~T~ } Iterator~t~ \u003c.. Collection~T~ class ConcreteIterator~T~ { +hasNext()bool +curruent()T +next() -iterState -collection } class ConcreteCollection~T~ { +iter()Iterator~T~ } ConcreteIterator~T~ \u003c--\u003e ConcreteCollection~T~ ConcreteCollection~T~ ..|\u003e Collection~T~ ConcreteIterator~T~ ..|\u003e Iterator~T~ 适用性 当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。\n迭代器封装了与复杂数据结构进行交互的细节， 为客户端提供多个访问集合元素的简单方法。 这种方式不仅对客户端来说非常方便， 而且能避免客户端在直接与集合交互时执行错误或有害的操作， 从而起到保护集合的作用。\n使用该模式可以减少程序中重复的遍历代码。\n重要迭代算法的代码往往体积非常庞大。 当这些代码被放置在程序业务逻辑中时， 它会让原始代码的职责模糊不清， 降低其可维护性。 因此， 将遍历代码移到特定的迭代器中可使程序代码更加精炼和简洁。\n如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。\n该模式为集合和迭代器提供了一些通用接口。 如果你在代码中使用了这些接口， 那么将其他实现了这些接口的集合和迭代器传递给它时， 它仍将可以正常运行。\n效果 单一职责原则。 通过将体积庞大的遍历算法代码抽取为独立的类， 你可对客户端代码和集合进行整理。\n开闭原则。 你可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。\n你可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。\n相似的， 你可以暂停遍历并在需要时继续。\n如果你的程序只与简单的集合进行交互， 应用该模式可能会矫枉过正。\n对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。\n与其他模式的关系 你可以使用迭代器模式树。\n你可以同时使用工厂方法模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。\n你可以同时使用备忘录模式来获取当前迭代器的状态， 并且在需要的时候进行回滚。\n可以同时使用访问者模式来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。\n","date":"2023-01-18T00:00:00Z","permalink":"https://moefulye.github.io/p/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","title":"迭代器模式"},{"content":"定义 运用共享技术有效的支持大量细粒度的对象。\n所谓享元，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。\n当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的\n类图 classDiagram note for FlyweightFactory \"GetFlyweight(key){\\n如果键值对应的享元存在\\n返回对应享元\\n否则\\n根据键值创建享元对象添加到池中并返回\\n}\" class FlyweightFactory { +GetFlywight(key) } class Flyweight{ +Operation(externalState) -internalState } FlyweightFactory o--\u003e Flyweight :flyweightPool note for Context \"constructor(repeatingState,uniqueState){\\n把独有状态赋给对应的成员\\n调用享元工厂的方法返回享元保存引用\\n}\" note for Context \"operation(){ flyweight.operation(uniqueState) }\" class Context{ +constructor(repeatingState,uniqueState) +operation() -uniqueState -flyweight } Context ..\u003e FlyweightFactory Context o--\u003e Flyweight :repeatingState 例子 假定你开发了一款游戏实现一个真实的粒子系统， 并将其作为游戏的特色。 大量的子弹、 导弹和爆炸弹片会在整个地图上穿行， 为玩家提供紧张刺激的游戏体验。假定粒子类是这样的\nclassDiagram note for Particle \"一个粒子对象大概占21KB的空间\" class Particle{ +coords //8bit +vector //16B +speed //4B +color //1KB +sprite //20KB +move() +draw(cavans) } 假定有1_000_000个子弹实例，那么一共要消耗21GB的存储空间\n仔细观察Particle类， 你可能会注意到颜色 （color） 和精灵图 （sprite） 这两个成员变量所消耗的内存要比其他变量多得多。 更糟糕的是， 对于所有的粒子来说， 这两个成员变量所存储的数据几乎完全一样 （比如所有子弹的颜色和精灵图都一样）。\n每个粒子的另一些状态 （坐标、 移动矢量和速度） 则是不同的。 因为这些成员变量的数值会不断变化。 这些数据代表粒子在存续期间不断变化的情景， 但每个粒子的颜色和精灵图则会保持不变。\n对象的常量数据通常被称为内在状态， 其位于对象中， 其他对象只能读取但不能修改其数值。 而对象的其他状态常常能被其他对象 “从外部” 改变， 因此被称为外在状态。\n享元模式建议不在对象中存储外在状态， 而是将其传递给依赖于它的一个特殊方法。 程序只在对象中保存内在状态， 以方便在不同情景下重用。 这些对象的区别仅在于其内在状态 （与外在状态相比， 内在状态的变体要少很多）， 因此你所需的对象数量会大大削减。\n让我们回到游戏中。 假如能从粒子类中抽出外在状态， 那么我们只需三个不同的对象 （子弹、 导弹和弹片） 就能表示游戏中的所有粒子。 你现在很可能已经猜到了， 我们将这样一个仅存储内在状态的对象称为享元。\n享元与不可变性 由于享元对象可在不同的情景中使用， 你必须确保其状态不能被修改。 享元类的状态只能由构造函数的参数进行一次性初始化， 它不能对其他对象公开其设置器或公有成员变量。\n享元工厂 为了能更方便地访问各种享元， 你可以创建一个工厂方法来管理已有享元对象的缓存池。 工厂方法从客户端处接收目标享元对象的内在状态作为参数， 如果它能在缓存池中找到所需享元， 则将其返回给客户端； 如果没有找到， 它就会新建一个享元， 并将其添加到缓存池中。\n你可以选择在程序的不同地方放入该函数。 最简单的选择就是将其放置在享元容器中。 除此之外， 你还可以新建一个工厂类， 或者创建一个静态的工厂方法并将其放入实际的享元类中。\n适用性 仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。 应用该模式所获的收益大小取决于使用它的方式和情景。 它在下列情况中最有效： 程序需要生成数量巨大的相似对象 这将耗尽目标设备的所有内存 对象中包含可抽取且能在多个对象间共享的重复状态。 效果 如果程序中有很多相似对象， 那么你将可以节省大量内存。 你可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。 代码会变得更加复杂。 团队中的新成员总是会问： ​ “为什么要像这样拆分一个实体的状态？”。 与其他模式的关系 你可以使用享元模式实现组合模式树的共享叶节点以节省内存。\n享元展示了如何生成大量的小型对象， 外观模式则展示了如何用一个对象来代表整个子系统。\n如果你能将对象的所有共享状态简化为一个享元对象， 那么享元就和单例模式类似了。 但这两个模式有两个根本性的不同。\n只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。 单例对象可以是可变的。 享元对象是不可变的。 ","date":"2023-01-17T00:00:00Z","permalink":"https://moefulye.github.io/p/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","title":"享元模式"},{"content":"定义 代理模式是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。\n类图 classDiagram class Service{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +request()* } class ConcreteService{ +request() } note for Proxy \"request(){\\n...\\nrealService.request()\\n...\\n}\" class Proxy{ +requset() -realService } ConcreteService ..|\u003e Service Proxy ..|\u003e Service Proxy o--\u003e ConcreteService :realService 服务接口 （Service） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。\n服务 （ConcreteService） 类提供了一些实用的业务逻辑。\n代理 （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。通常情况下， 代理会对其服务对象的整个生命周期进行管理。\nc++实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; using namespace std; class Subject { public: virtual void request() = 0; virtual ~Subject() {} }; class RealSubject : public Subject { public: void request() { cout \u0026lt;\u0026lt; \u0026#34;RealSubject::request()\u0026#34; \u0026lt;\u0026lt; endl; } ~RealSubject() { cout \u0026lt;\u0026lt; \u0026#34;~RealSubject()\u0026#34; \u0026lt;\u0026lt; endl; } }; class Proxy : public Subject { private: Subject *realSubject; bool checkAccess() { cout \u0026lt;\u0026lt; \u0026#34;Proxy::checkAccess()\u0026#34; \u0026lt;\u0026lt; endl; return true; } void logAccess() { cout \u0026lt;\u0026lt; \u0026#34;Proxy::logAccess()\u0026#34; \u0026lt;\u0026lt; endl; } public: Proxy(Subject *realSubject) : realSubject(realSubject) {} ~Proxy() { delete realSubject; } void request() { if (checkAccess()) { realSubject-\u0026gt;request(); logAccess(); } } }; int main(int argc, char *argv[]) { Subject *subject = new Proxy(new RealSubject()); subject-\u0026gt;request(); delete subject; return 0; } 应用场景 远程代理 代理磁盘或者远程主机上的对象 虚代理 在初始化时不必要创建对应的被代理的对象，可以根据需要创建，这在创建被代理的对象开销大时用处很大 保护代理 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式 智能指针unique_ptr, shared_ptr\u0026hellip; 托管被代理对象，管理它的生命周期 效果 优点\n你可以在客户端毫无察觉的情况下控制服务对象。 如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。 即使服务对象还未准备好或不存在， 代理也可以正常工作。 开闭原则。 你可以在不对服务或客户端做出修改的情况下创建新代理。 缺点\n代码可能会变得复杂， 因为需要新建许多类。 服务响应可能会延迟。 与其他模式的关系 适配器模式能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰模式则能为对象提供加强的接口。\n外观模式与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。\n装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。\n","date":"2023-01-17T00:00:00Z","permalink":"https://moefulye.github.io/p/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","title":"代理模式"},{"content":"定义 类图 classDiagram class Invoker{ -commands +addCommand(command) +execute() ///+undo() } class Receiver{ +operationA(...) +operationB(...) +operationC(...) } class Command{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +execute() ///+undo() } class ConcreteCommandA{ +execute() ///+undo() } class ConcreteCommandB{ +execute() ///+undo() } ConcreteCommandA ..|\u003e Command ConcreteCommandB ..|\u003e Command ConcreteCommandA o--\u003e Receiver :receiver ConcreteCommandB o--\u003e Receiver :receiver Invoker o--\u003e Command :commands 发送者 （Sender）——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。\n命令 （Command） 接口通常仅声明一个执行命令的方法。\n具体命令 （Concrete Commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。\n接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。\n接收者 （Receiver） 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。\n客户端 （Client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。\nc++实现 1 //懒得编了 适用性 如果你需要通过操作来参数化对象， 可使用命令模式。 命令模式可将特定的方法调用转化为独立对象。 这一改变也带来了许多有趣的应用： 你可以将命令作为方法的参数进行传递、 将命令保存在其他对象中， 或者在运行时切换已连接的命令等。\n举个例子： 你正在开发一个 GUI 组件 （例如上下文菜单）， 你希望用户能够配置菜单项， 并在点击菜单项时触发操作。\n如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。\n同其他对象一样， 命令也可以实现序列化 （序列化的意思是转化为字符串）， 从而能方便地写入文件或数据库中。 一段时间后， 该字符串可被恢复成为最初的命令对象。 因此， 你可以延迟或计划命令的执行。 但其功能远不止如此！ 使用同样的方式， 你还可以将命令放入队列、 记录命令或者通过网络发送命令。\n如果你想要实现操作回滚功能， 可使用命令模式。\n尽管有很多方法可以实现撤销和恢复功能， 但命令模式可能是其中最常用的一种。\n为了能够回滚操作， 你需要实现已执行操作的历史记录功能。 命令历史记录是一种包含所有已执行命令对象及其相关程序状态备份的栈结构。\n这种方法有两个缺点。 首先， 程序状态的保存功能并不容易实现， 因为部分状态可能是私有的。 你可以使用备忘录模式来在一定程度上解决这个问题。\n其次， 备份状态可能会占用大量内存。 因此， 有时你需要借助另一种实现方式： 命令无需恢复原始状态， 而是执行反向操作。 反向操作也有代价： 它可能会很难甚至是无法实现。\n效果 单一职责原则。 你可以解耦触发和执行操作的类。\n开闭原则。 你可以在不修改已有客户端代码的情况下在程序中创建新的命令。\n你可以实现撤销和恢复功能。\n你可以实现操作的延迟执行。\n你可以将一组简单命令组合成一个复杂命令。\n代码可能会变得更加复杂， 因为你在发送者和接收者之间增加了一个全新的层次。\n与其他模式的关系 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。 命令在发送者和请求者之间建立单向连接。 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。 观察者允许接收者动态地订阅或取消接收请求。 责任链的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。\n还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。 你可以同时使用命令和备忘录模式来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。\n命令和策略模式看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。\n你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。 另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。 原型模式可用于保存命令的历史记录。\n你可以将访问者模式视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作\n","date":"2023-01-17T00:00:00Z","permalink":"https://moefulye.github.io/p/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","title":"命令模式"},{"content":"定义 门面模式：（Facade Design Pattern）门面模式也叫外观模式，门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。\n门面模式原理和实现也比较简单，应用场景也比较明确，主要在接口设计方面使用。\n类图 classDiagram class Facade{ +operator() } external --\u003e Facade Facade --\u003e SubModelA Facade --\u003e SubModelB Facade --\u003e SubModelC 门面角色：客户端调用这个角色的方法。此角色知晓相关的子系统的功能和责任。正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统中去。 子系统角色：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合。每一个子系统都可以被客户端直接调用，或者被门面角色直接调用。子系统并不知道门面的存在，罪域子系统而言，门面仅仅是另一个客户端而已。 效果 1. 解决易用性问题\n这个很容易理解，门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，Linux 系统调用函数就可以看作一种“门面”。它是 Linux 操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。\n2. 解决性能问题\n我们知道，App 和服务器之间是通过移动网络通信的，网络通信耗时比较多，为了提高 App 的响应速度，我们要尽量减少 App 与服务器之间的网络通信次数。\n假设，完成某个业务功能（比如显示某个页面信息）需要“依次”调用 a、b、d 三个接口。如果我们发现过多的网络通信次数造成客户端响应速度慢，此时就可以利用门面模式，让后端服务器提供一个包裹 a、b、d 三个接口调用的接口 x。App 客户端调用一次接口 x 就可以了，减少了网络通信次数。\n3. 解决分布式事务问题 假设在一个金融系统中，用户注册需要创建用户和创建用户钱包。用户注册需要支持事务，也就是创建用户和钱包两个操作，要么都成功，要么都失败，不能一个成功，一个失败。 要想两个接口调用在一个事务中执行，是比较难以实现的。此时，我们就可以使用门面模式，将两个接口操作实现放在一个接口中，并使用 Spring 框架提供的事务来控制。\n","date":"2023-01-17T00:00:00Z","permalink":"https://moefulye.github.io/p/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","title":"外观模式"},{"content":"定义 组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。\n类图 classDiagram class Component{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +operation()* +add(component: Component)* +remove()* +children()*Collection~Component~ } class Leaf{ +operation() } class Composite{ +operation() +add(component: Component) +remove() +children()Collection~Component~ } Leaf ..|\u003eComponent Composite..|\u003eComponent Composite o--\u003e Component :children c++实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class File { public: typedef vector\u0026lt;File *\u0026gt; \u0026amp;FileList; virtual string name() = 0; virtual void rename(string name) = 0; virtual File *parent() = 0; virtual string path() = 0; virtual void set_parent(File *parent) = 0; virtual FileList children() = 0; virtual File *child(int index) = 0; virtual void add(File *file) = 0; virtual void remove(int index) = 0; }; class Directory : public File { private: string _name; File *_parent; vector\u0026lt;File *\u0026gt; _children; public: Directory(string name, File *parent = nullptr) : _name(name), _parent(parent) { if (_parent != nullptr) { _parent-\u0026gt;add(this); } } string name() { return _name; } void rename(string name) { _name = name; } File *parent() { return _parent; } void set_parent(File *parent) { _parent = parent; } string path() { if (_parent == nullptr) return _name; else return _parent-\u0026gt;path() + \u0026#34;/\u0026#34; + _name; } vector\u0026lt;File *\u0026gt; \u0026amp;children() { return _children; } File *child(int index) { return _children[index]; } void add(File *file) { _children.push_back(file); } void remove(int index) { _children.erase(_children.begin() + index); } }; class TextFile : public File { private: string _name; File *_parent; vector\u0026lt;File *\u0026gt; _null; public: TextFile(string name, File *parent = nullptr) : _name(name), _parent(parent), _null(0) { if (_parent != nullptr) { _parent-\u0026gt;add(this); } } string name() { return _name; } void rename(string name) { _name = name; } File *parent() { return _parent; } void set_parent(File *parent) { _parent = parent; } string path() { if (_parent == nullptr) return _name; else return _parent-\u0026gt;path() + \u0026#34;/\u0026#34; + _name; } vector\u0026lt;File *\u0026gt; \u0026amp;children() { return _null; } File *child(int index) { return nullptr; } void add(File *file) {} void remove(int index) {} }; template \u0026lt;typename func\u0026gt; void file_iterator(File *file, func f) { f(file); for (File *child : file-\u0026gt;children()) { file_iterator(child, f); } } int main() { Directory *root = new Directory(\u0026#34;root\u0026#34;); Directory *home = new Directory(\u0026#34;home\u0026#34;, root); Directory *user = new Directory(\u0026#34;user\u0026#34;, home); TextFile *a = new TextFile(\u0026#34;a.txt\u0026#34;, user); TextFile *b = new TextFile(\u0026#34;b.txt\u0026#34;, user); TextFile *c = new TextFile(\u0026#34;c.txt\u0026#34;, home); TextFile *d = new TextFile(\u0026#34;d.txt\u0026#34;, root); file_iterator(root, [](File *file) { cout \u0026lt;\u0026lt; file-\u0026gt;path() \u0026lt;\u0026lt; endl; }); return 0; } 效果 高层模块调用简单。 节点自由增加。 例子 算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。 ","date":"2023-01-17T00:00:00Z","permalink":"https://moefulye.github.io/p/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","title":"组合模式"},{"content":"定义 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。它是作为现有的类的一个包装。\n若要扩展一个对象的功能，装饰器模式提供了比继承更有弹性的替代方案。组合优于继承。\n类图 classDiagram class Component{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +operation()* } class ConcreteComponentA{ +operation() } class ConcreteComponentB{ +operation() } class Decorator{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +operation() +component :Component } ConcreteComponentA ..|\u003e Component ConcreteComponentB ..|\u003e Component Decorator ..|\u003e Component Decorator o--\u003e Component :component note for ConcreteDecoratorA \"operation调用父类同名方法并\\n新增一些操作\" class ConcreteDecoratorA{ +operation() } class ConcreteDecoratorB{ +operation() } ConcreteDecoratorA --|\u003e Decorator ConcreteDecoratorB --|\u003e Decorator 角色组成：\n抽象构件角色(Component): 定义可以动态添加任务的对象的接口 具体构件角色(ConcreteComponent)：定义一个要被装饰器装饰的对象，即 Component 的具体实现 抽象装饰器(Decorator): 持有一个构件（Conponent）对象的实例，并定义一个和抽象构件一致的接口。维护对组件对象和其子类组件的引用 具体装饰器角色(ConcreteDecorator)：向组件添加新的职责 适用性 需要扩展一个类的功能，或给一个类增加附加责任。 需要动态的给一个对象增加功能，这些功能可以再动态地撤销。 需要增加一些基本功能的排列组合而产生的非常大量的功能，从而使继承变得不现实。 例子 java InputStream 1 2 3 4 InputStream in = new FileImputStream(\u0026#34;/user/test.txt\u0026#34;); InputStream bin = new BufferedInputStream(in); DataInputStream din = new DataInputStream(bin); int data = din.readInt(); ","date":"2023-01-17T00:00:00Z","permalink":"https://moefulye.github.io/p/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/","title":"装饰器模式"},{"content":"定义 责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。\n类图 classDiagram class Handler{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +setNext(handler)* +handle(context)* } note \"handle(context){\\nif can handle\\nthen do something\\nelse\\ncall next.handle and pass context to it\\n}\" class ConcreteHandlerA{ +setNext(handler) +handle(context) -canHandle(context) -Handler nextHandler } class ConcreteHandlerB{ +setNext(handler) +handle(context) -canHandle(context) -Handler next } ConcreteHandlerA ..|\u003e Handler ConcreteHandlerB ..|\u003e Handler ConcreteHandlerA o--\u003e Handler :next ConcreteHandlerB o--\u003e Handler :next rust实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 //main.rs mod hospital; use hospital::*; fn main() { let mut xiaowang = Patient::new(\u0026#34;小王\u0026#34;); let hospital = Hospital::correct_flow(); hospital.handle(\u0026amp;mut xiaowang); let mut xiaoli = Patient::new(\u0026#34;小李\u0026#34;); let hospital = Hospital::error_flow(); hospital.handle(\u0026amp;mut xiaoli); } //hospital.rs //流程: 挂号 -\u0026gt; 医生 -\u0026gt; 收费 -\u0026gt;药房 pub struct Hospital{ first_handler :Option\u0026lt;Box\u0026lt;dyn Handler\u0026gt;\u0026gt;, } impl Hospital{ pub fn new() -\u0026gt; Hospital{ Hospital{ first_handler: None, } } fn add_handler(\u0026amp;mut self, handler: Box\u0026lt;dyn Handler\u0026gt;){ if let Some(ref mut first_handler) = self.first_handler{ first_handler.pass(handler); }else{ self.first_handler = Some(handler); } } pub fn handle(\u0026amp;self, patient:\u0026amp;mut Patient){ if let Some(ref first_handler) = self.first_handler{ let res= first_handler.handle(patient); match res{ Ok(_) =\u0026gt; println!(\u0026#34;看医院成功!\u0026#34;), Err(_) =\u0026gt; println!(\u0026#34;看医院失败!\u0026#34;), } }else{ println!(\u0026#34;空的医院!\u0026#34;); } } //正确流程 pub fn correct_flow()-\u0026gt;Hospital{ let mut hospital = Hospital::new(); hospital.add_handler(Box::new(Register::new())); hospital.add_handler(Box::new(Doctor::new())); hospital.add_handler(Box::new(Payment::new())); hospital.add_handler(Box::new(Pharmacy::new())); hospital } //错误流程 pub fn error_flow()-\u0026gt;Hospital{ let mut hospital = Hospital::new(); hospital.add_handler(Box::new(Register::new())); hospital.add_handler(Box::new(Register::new())); hospital.add_handler(Box::new(Payment::new())); hospital.add_handler(Box::new(Doctor::new())); hospital.add_handler(Box::new(Pharmacy::new())); hospital } } pub struct Patient{ name: String, has_registered: bool, doctor_has_seen: bool, has_paid: bool, } impl Patient{ pub fn new(name :\u0026amp;str) -\u0026gt; Patient{ Patient{ name: name.to_string(), has_registered: false, doctor_has_seen: false, has_paid: false, } } pub fn register(\u0026amp;mut self){ self.has_registered = true; } pub fn has_registered(\u0026amp;self) -\u0026gt; bool{ self.has_registered } pub fn see_doctor(\u0026amp;mut self){ self.doctor_has_seen = true; } pub fn has_seen_doctor(\u0026amp;self) -\u0026gt; bool{ self.doctor_has_seen } pub fn pay(\u0026amp;mut self){ self.has_paid = true; } pub fn has_paid(\u0026amp;self) -\u0026gt; bool{ self.has_paid } } trait Handler { fn pass(\u0026amp;mut self, handler: Box\u0026lt;dyn Handler\u0026gt;); fn handle(\u0026amp;self, patient: \u0026amp;mut Patient) -\u0026gt; Result\u0026lt;(),()\u0026gt;; } struct Register{ next: Option\u0026lt;Box\u0026lt;dyn Handler\u0026gt;\u0026gt;, } impl Register{ pub fn new() -\u0026gt; Register{ Register{ next: None, } } } impl Handler for Register{ fn pass(\u0026amp;mut self, handler: Box\u0026lt;dyn Handler\u0026gt;){ match self.next{ Some(ref mut next) =\u0026gt; next.pass(handler), None =\u0026gt; self.next = Some(handler), } } fn handle(\u0026amp;self, patient: \u0026amp;mut Patient) -\u0026gt; Result\u0026lt;(),()\u0026gt;{ if !patient.has_registered(){ println!(\u0026#34;{}正在挂号\u0026#34;, patient.name); patient.register(); println!(\u0026#34;{}挂号成功\u0026#34;, patient.name); }else{ println!(\u0026#34;{}已经挂号\u0026#34;, patient.name); } if let Some(ref next) = self.next{ next.handle(patient) }else{ Ok(()) } } } struct Doctor{ next: Option\u0026lt;Box\u0026lt;dyn Handler\u0026gt;\u0026gt;, } impl Doctor{ pub fn new() -\u0026gt; Doctor{ Doctor{ next: None, } } } impl Handler for Doctor{ fn pass(\u0026amp;mut self, handler: Box\u0026lt;dyn Handler\u0026gt;){ match self.next{ Some(ref mut next) =\u0026gt; next.pass(handler), None =\u0026gt; self.next = Some(handler), } } fn handle(\u0026amp;self, patient: \u0026amp;mut Patient) -\u0026gt; Result\u0026lt;(),()\u0026gt;{ if !patient.has_seen_doctor(){ println!(\u0026#34;{}正在看医生\u0026#34;, patient.name); patient.see_doctor(); println!(\u0026#34;{}看医生成功\u0026#34;, patient.name); }else{ println!(\u0026#34;{}已经看过医生\u0026#34;, patient.name); } if !patient.has_registered(){ println!(\u0026#34;{}没有挂号\u0026#34;, patient.name); return Err(()); } if let Some(ref next) = self.next{ next.handle(patient) }else{ Ok(()) } } } struct Payment{ next: Option\u0026lt;Box\u0026lt;dyn Handler\u0026gt;\u0026gt;, } impl Payment{ pub fn new() -\u0026gt; Payment{ Payment{ next: None, } } } impl Handler for Payment{ fn pass(\u0026amp;mut self, handler: Box\u0026lt;dyn Handler\u0026gt;){ match self.next{ Some(ref mut next) =\u0026gt; next.pass(handler), None =\u0026gt; self.next = Some(handler), } } fn handle(\u0026amp;self, patient: \u0026amp;mut Patient) -\u0026gt; Result\u0026lt;(),()\u0026gt;{ if !patient.has_paid(){ println!(\u0026#34;{}正在付费\u0026#34;, patient.name); patient.pay(); println!(\u0026#34;{}付费成功\u0026#34;, patient.name); }else{ println!(\u0026#34;{}已经付过费\u0026#34;, patient.name); } if !patient.has_registered(){ println!(\u0026#34;{}没有挂号\u0026#34;, patient.name); return Err(()); } if !patient.has_seen_doctor(){ println!(\u0026#34;{}没有看医生\u0026#34;, patient.name); return Err(()); } if let Some(ref next) = self.next{ next.handle(patient) }else{ Ok(()) } } } struct Pharmacy{ next: Option\u0026lt;Box\u0026lt;dyn Handler\u0026gt;\u0026gt;, } impl Pharmacy{ pub fn new() -\u0026gt; Pharmacy{ Pharmacy{ next: None, } } } impl Handler for Pharmacy{ fn pass(\u0026amp;mut self, handler: Box\u0026lt;dyn Handler\u0026gt;){ match self.next{ Some(ref mut next) =\u0026gt; next.pass(handler), None =\u0026gt; self.next = Some(handler), } } fn handle(\u0026amp;self, patient: \u0026amp;mut Patient) -\u0026gt; Result\u0026lt;(),()\u0026gt;{ if !patient.has_registered(){ println!(\u0026#34;{}没有挂号\u0026#34;, patient.name); return Err(()); } if !patient.has_seen_doctor(){ println!(\u0026#34;{}没有看医生\u0026#34;, patient.name); return Err(()); } if !patient.has_paid(){ println!(\u0026#34;{}没有付费\u0026#34;, patient.name); return Err(()); } println!(\u0026#34;{}正在取药\u0026#34;, patient.name); println!(\u0026#34;{}取药成功\u0026#34;, patient.name); Ok(()) } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/chain` 小王正在挂号 小王挂号成功 小王正在看医生 小王看医生成功 小王正在付费 小王付费成功 小王正在取药 小王取药成功 看医院成功! 小李正在挂号 小李挂号成功 小李已经挂号 小李正在付费 小李付费成功 小李没有看医生 看医院失败! 适用性 当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。\n该模式能将多个处理者连接成一条链。 接收到请求后， 它会 “询问” 每个处理者是否能够对其进行处理。 这样所有处理者都有机会来处理请求。\n当必须按顺序执行多个处理者时， 可以使用该模式。\n无论你以何种顺序将处理者连接成一条链， 所有请求都会严格按照顺序通过链上的处理者。\n如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。\n如果在处理者类中有对引用成员变量的设定方法， 你将能动态地插入和移除处理者， 或者改变其顺序。\n效果 你可以控制请求处理的顺序。\n单一职责原则。 你可对发起操作和执行操作的类进行解耦。\n开闭原则。 你可以在不更改现有代码的情况下在程序中新增处理者。\n部分请求可能未被处理。\n与其他模式的关系 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式： 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。 命令在发送者和请求者之间建立单向连接。 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。 观察者允许接收者动态地订阅或取消接收请求。\n责任链通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。\n责任链的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。\n还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。\n责任链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。\n责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。\n","date":"2023-01-17T00:00:00Z","permalink":"https://moefulye.github.io/p/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","title":"责任链模式"},{"content":"定义 把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。\n人话: 某一接口可视为两个独立变化维度，假定这两个维度的实现各有$M$和$N$种，假定采用传统设计模式那么要设计$M\\times N$个实现类，很容易出现实现类数量爆炸的问题，为了解决该问题，对于这两个变化维度我们可以设计两个接口，那么各有$M$和$N$个实现类，再把这个两个接口组装起来比如让某个接口去使用某些接口。那么我们通过实现了$M+N$个类就解决了上面的问题\n类图 classDiagram class Abstraction{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +Operation() } RefinedAbstraction ..|\u003e Abstraction class Implementor{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +OperationImp()* } class ConcreteImplementorA{ +OperationImp() } class ConcreteImplementorB{ +OperationImp() } ConcreteImplementorA ..|\u003e Implementor ConcreteImplementorB ..|\u003e Implementor Abstraction o--\u003e Implementor :imp ：\n抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。 修正抽象化(RefinedAbstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。 实现化(Implementor)角色：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。 具体实现化(ConcreteImplementor)角色：这个角色给出实现化角色接口的具体实现。 c++实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Drink { public: virtual string name() = 0; }; class Coffee : public Drink { public: string name() { return \u0026#34;Coffee\u0026#34;; } }; class Tea : public Drink { public: string name() { return \u0026#34;Tea\u0026#34;; } }; class Milk : public Drink { public: string name() { return \u0026#34;Milk\u0026#34;; } }; class DrinkWithFlavor { private: Drink *drink; public: virtual string flavor() = 0; DrinkWithFlavor(Drink *drink) : drink(drink) {} void show() { cout \u0026lt;\u0026lt; \u0026#34;Drink \u0026#34; + drink-\u0026gt;name() \u0026lt;\u0026lt; \u0026#34; with \u0026#34; \u0026lt;\u0026lt; flavor() \u0026lt;\u0026lt; endl; } }; class DrinkWithSugar : public DrinkWithFlavor { public: DrinkWithSugar(Drink *drink) : DrinkWithFlavor(drink) {} string flavor() { return \u0026#34;Sugar\u0026#34;; } }; class DrinkWithHoney : public DrinkWithFlavor { public: DrinkWithHoney(Drink *drink) : DrinkWithFlavor(drink) {} string flavor() { return \u0026#34;Honey\u0026#34;; } }; int main() { Drink *coffee = new Coffee(); Drink *tea = new Tea(); Drink *milk = new Milk(); DrinkWithFlavor *coffeeWithSugar = new DrinkWithSugar(coffee); DrinkWithFlavor *teaWithHoney = new DrinkWithHoney(tea); DrinkWithFlavor *milkWithSugar = new DrinkWithSugar(milk); coffeeWithSugar-\u0026gt;show(); teaWithHoney-\u0026gt;show(); milkWithSugar-\u0026gt;show(); return 0; } 效果 优点：\n分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象。 在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。 桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。 缺点：\n桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。 ","date":"2023-01-16T00:00:00Z","permalink":"https://moefulye.github.io/p/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","title":"桥接模式"},{"content":"定义 将一个类的接口转换成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类能在一起工作 有继承和组合两种实现方式这里我们采用组合实现\n类图 classDiagram class TargetInterface{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +methodA()* } class InterfacetobeAdapted{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +methodB()* } class Adapter{ -InterfacetobeAdapted adaptee +constructor(adaptee: InterfacetobeAdapted) +setAdaptee(adaptee: InterfacetobeAdapted) +methodA() } Adapter o--\u003eInterfacetobeAdapted :adaptee Adapter ..|\u003e TargetInterface c++实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; using namespace std; class HeatGenerator { public: virtual void generateHeat() = 0; }; class ElectricGenerator { public: virtual void generateElectricity() = 0; }; class Stove : public HeatGenerator { public: void generateHeat() { cout \u0026lt;\u0026lt; \u0026#34;Generating heat\u0026#34; \u0026lt;\u0026lt; endl; } }; class Heat2Electric : public ElectricGenerator { public: Heat2Electric(HeatGenerator *adaptee) : adaptee(adaptee) {} void set_adaptee(HeatGenerator *adaptee) { this-\u0026gt;adaptee = adaptee; } void generateElectricity() { adaptee-\u0026gt;generateHeat(); cout \u0026lt;\u0026lt; \u0026#34;Converting heat to electric\u0026#34; \u0026lt;\u0026lt; endl; } private: HeatGenerator *adaptee; }; class ElecticFan { public: ElecticFan(ElectricGenerator *power) : power(power) {} void run() { cout \u0026lt;\u0026lt; \u0026#34;Running electric fan\u0026#34; \u0026lt;\u0026lt; endl; } private: ElectricGenerator *power; }; int main() { auto power = new Heat2Electric(new Stove()); power-\u0026gt;generateElectricity(); auto fan = new ElecticFan(power); fan-\u0026gt;run(); return 0; } 效果 优点：\n可以让任何两个没有关联的类一起运行。 提高了类的复用。 增加了类的透明度。 灵活性好。 缺点：\n过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 ","date":"2023-01-16T00:00:00Z","permalink":"https://moefulye.github.io/p/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","title":"适配器模式"},{"content":"定义 原型模式是创建型模式的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。\n原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。\n类图 classDiagram class Prototype{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; clone()*Prototype } class A{ clone() A } class B{ clone() B } A ..|\u003e Prototype B ..|\u003e Prototype c++实现 即拷贝构造函数注意深拷贝和浅拷贝\n","date":"2023-01-14T00:00:00Z","permalink":"https://moefulye.github.io/p/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"原型模式"},{"content":"定义 单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为\n类图 classDiagram class Singleton{ -Singleton instance$ -Data data -constructor() +instance()$ Singleton } c++(不完善的)实现 懒汉 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; using namespace std; class LazyloadSingleton { private: static LazyloadSingleton *instance; LazyloadSingleton() { value = 0; } public: int value; static const LazyloadSingleton \u0026amp;getInstance() { if (instance == NULL) { instance = new LazyloadSingleton(); } return *instance; } }; LazyloadSingleton *LazyloadSingleton::instance = NULL; int main() { std::cout \u0026lt;\u0026lt; LazyloadSingleton::getInstance().value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; LazyloadS`ingleton::getInstance().value \u0026lt;\u0026lt; std::endl; return 0; } 单线程实现，多线程不安全\n饿汉 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; class LazyloadSingleton { private: static LazyloadSingleton *instance; LazyloadSingleton() { value = 0; } public: int value; static const LazyloadSingleton \u0026amp;getInstance() { return *instance; } }; LazyloadSingleton *LazyloadSingleton::instance = new LazyloadSingleton(); int main() { std::cout \u0026lt;\u0026lt; LazyloadSingleton::getInstance().value \u0026lt;\u0026lt; std::endl; return 0; } no-local static对象在不同编译单元中的初始化顺序是未定义的。也即，static Singleton\u0026amp; getInstance()调用时还未初始化instance此时会返回一个未定义的实例。\n","date":"2023-01-13T00:00:00Z","permalink":"https://moefulye.github.io/p/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"单例模式"},{"content":"原因 要创建的对象需要一系列复杂的初始化操作，比如查配置文件、查数据库表、初始化成员对象等，如果把这些逻辑放在构造函数中，会极大影响代码的可读性。不妨定义一个类来专门负责对象的创建，这样的类就是工厂类，这种做法就是工厂模式，在任何需要生成复杂对象的地方，都可以使用工厂模式。\n简单（静态）工厂 类图 classDiagram class Factory{ +newProduct()$Product } class Product Factory ..\u003e Product c++实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; using namespace std; class Animal { public: virtual void speak() { cout \u0026lt;\u0026lt; \u0026#34;Animal speaking\u0026#34; \u0026lt;\u0026lt; endl; }; }; class Dog : public Animal { public: void speak() { cout \u0026lt;\u0026lt; \u0026#34;汪\u0026#34; \u0026lt;\u0026lt; endl; } ~Dog() {} }; class Cat : public Animal { public: void speak() { cout \u0026lt;\u0026lt; \u0026#34;喵\u0026#34; \u0026lt;\u0026lt; endl; } ~Cat() {} }; class AnimalFactory { public: enum class AnimalType { Dog, Cat, Unknown }; static Dog *createDog() { return new Dog(); } static Cat *createCat() { return new Cat(); } static Animal *createAnimal(AnimalType type) { switch (type) { case AnimalType::Dog: return new Dog(); case AnimalType::Cat: return new Cat(); default: return new Animal(); } } }; int main() { Animal *dog = AnimalFactory::createAnimal(AnimalFactory::AnimalType::Dog); Animal *cat = AnimalFactory::createAnimal(AnimalFactory::AnimalType::Cat); Animal *Unknown = AnimalFactory::createAnimal(AnimalFactory::AnimalType::Unknown); dog-\u0026gt;speak(); cat-\u0026gt;speak(); Unknown-\u0026gt;speak(); return 0; } 优缺点 简单代码量小 当需求改变时, 需要创建其他类的对象时要修改原有代码，不符合开闭原则 工厂方法 类图 classDiagram class Product { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class Factory { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +newProduct()*Product } class ConcreteFactory { +newProduct()Product } class ConcreteProduct ConcreteProduct ..|\u003e Product ConcreteFactory ..|\u003e Factory ConcreteFactory ..\u003e ConcreteProduct 与简单工厂方法比较 相较于简单工厂方法，本模式提供了一个接口，当我们需要新的类型的对象时，我们只要提供一个具体的类和工厂类即可，不会影响原有代码，符合开闭原则\nc++实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; using namespace std; class Animal { public: virtual void speak() { cout \u0026lt;\u0026lt; \u0026#34;Animal speaking\u0026#34; \u0026lt;\u0026lt; endl; }; }; class AnimalFactory { public: virtual Animal *createAnimal() = 0; }; class Dog : public Animal { public: void speak() { cout \u0026lt;\u0026lt; \u0026#34;汪\u0026#34; \u0026lt;\u0026lt; endl; } ~Dog() {} }; class Cat : public Animal { public: void speak() { cout \u0026lt;\u0026lt; \u0026#34;喵\u0026#34; \u0026lt;\u0026lt; endl; } ~Cat() {} }; class DogFactory : public AnimalFactory { public: Animal *createAnimal() { return new Dog(); } }; class CatFactory : public AnimalFactory { public: Animal *createAnimal() { return new Cat(); } }; int main() { AnimalFactory *dogFactory = new DogFactory(); Animal *dog = dogFactory-\u0026gt;createAnimal(); dog-\u0026gt;speak(); AnimalFactory *catFactory = new CatFactory(); Animal *cat = catFactory-\u0026gt;createAnimal(); cat-\u0026gt;speak(); return 0; } 抽象工厂 工厂模式的问题 工厂模式对于每一个具体产品，都要编写一个工厂类。如电脑配件产品，有华硕牌主板、华硕牌显卡、华硕牌电源、联想主板、联想显卡、联想电源\u0026hellip;\u0026hellip;如果每一种工厂都要生产一种产品的话需要设计6个具体工厂类。容易造成子类数量爆炸的问题，如下图所示\nflowchart LR; factoryA1--\u003e productA1 --\u003e product_interface factoryB1--\u003e productB1 --\u003e product_interface factoryC1--\u003e productC1 --\u003e product_interface factoryA2--\u003e productA2 --\u003e product_interface factoryB2--\u003e productB2 --\u003e product_interface factoryC2--\u003e productC2 --\u003e product_interface factoryA3--\u003e productA3 --\u003e product_interface factoryB3--\u003e productB3 --\u003e product_interface factoryC3--\u003e productC3 --\u003e product_interface 但是我们注意到有一个特征可以被抽取出来，比如产品的牌子、这里要生产两组产品产品: 华硕牌电子配件和联想电子配件。因此我们采用抽象工厂模式，每一个具体工厂生产不同牌子的产品。简单来说：工厂方法模式的工厂是创建出一种产品，而抽象工厂是创建出一类产品。对于抽象工厂来说。生产的产品有多级抽象属性。如这里的产品种类（显卡电源主板\u0026hellip;..）和产品品牌，且有一类抽象的实现比较稳定。如这里的产品种类。如果需要新生产显示器产品的话又要大改。那么我们可以把另一类抽象作为被抽取的特征\nflowchart LR; factoryA --\u003e productA1 factoryA --\u003e productA2 factoryA --\u003e productA3 factoryB --\u003e productB1 factoryB --\u003e productB2 factoryB --\u003e productB3 factoryC --\u003e productC1 factoryC --\u003e productC2 factoryC --\u003e productC3 productA1 --\u003e product1_interface productB1 --\u003e product1_interface productC1 --\u003e product1_interface productA2 --\u003e product2_interface productB2 --\u003e product2_interface productC2 --\u003e product2_interface productA3 --\u003e product3_interface productB3 --\u003e product3_interface productC3 --\u003e product3_interface product1_interface--\u003eproduct_interface product2_interface--\u003eproduct_interface product3_interface--\u003eproduct_interface 类图 classDiagram class Product{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class Product1{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class Product2{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class Product3{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } Product1 ..|\u003e Product Product2 ..|\u003e Product Product3 ..|\u003e Product class Factory{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; newProduct1()*Product1 newProduct2()*Product2 newProduct3()*Product3 } class FactoryA{ newProduct1()Product1 newProduct2()Product2 newProduct3()Product3 } class FactoryB{ newProduct1()Product1 newProduct2()Product2 newProduct3()Product3 } class FactoryC{ newProduct1()Product1 newProduct2()Product2 newProduct3()Product3 } FactoryA ..|\u003e Factory FactoryB ..|\u003e Factory FactoryC ..|\u003e Factory ProductA1 ..|\u003e Product1 ProductB1 ..|\u003e Product1 ProductC1 ..|\u003e Product1 ProductA2 ..|\u003e Product2 ProductB2 ..|\u003e Product2 ProductC2 ..|\u003e Product2 ProductA3 ..|\u003e Product3 ProductB3 ..|\u003e Product3 ProductC3 ..|\u003e Product3 FactoryA ..\u003e ProductA1 FactoryA ..\u003e ProductA2 FactoryA ..\u003e ProductA3 FactoryB ..\u003e ProductB1 FactoryB ..\u003e ProductB2 FactoryB ..\u003e ProductB3 FactoryC ..\u003e ProductC1 FactoryC ..\u003e ProductC2 FactoryC ..\u003e ProductC3 c++实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026lt;iostream\u0026gt; using namespace std; class ElecComponent { public: virtual void show() = 0; }; class Matherboard : public ElecComponent {}; class AsusMatherboard : public Matherboard { public: void show() { cout \u0026lt;\u0026lt; \u0026#34;Asus Matherboard\u0026#34; \u0026lt;\u0026lt; endl; } }; class LenovoMatherboard : public Matherboard { public: void show() { cout \u0026lt;\u0026lt; \u0026#34;Lenovo Matherboard\u0026#34; \u0026lt;\u0026lt; endl; } }; class GraphicsCard : public ElecComponent {}; class AsusGraphicsCard : public GraphicsCard { public: void show() { cout \u0026lt;\u0026lt; \u0026#34;Asus GraphicsCard\u0026#34; \u0026lt;\u0026lt; endl; } }; class LenovoGraphicsCard : public GraphicsCard { public: void show() { cout \u0026lt;\u0026lt; \u0026#34;Lenovo GraphicsCard\u0026#34; \u0026lt;\u0026lt; endl; } }; class PowerSupply : public ElecComponent {}; class AsusPowerSupply : public PowerSupply { public: void show() { cout \u0026lt;\u0026lt; \u0026#34;Asus PowerSupply\u0026#34; \u0026lt;\u0026lt; endl; } }; class LenovoPowerSupply : public PowerSupply { public: void show() { cout \u0026lt;\u0026lt; \u0026#34;Lenovo PowerSupply\u0026#34; \u0026lt;\u0026lt; endl; } }; class Factory { public: virtual Matherboard *newMatherboard() = 0; virtual GraphicsCard *newGraphicsCard() = 0; virtual PowerSupply *newPowerSupply() = 0; }; class AsusFactory : public Factory { public: Matherboard *newMatherboard() { return new AsusMatherboard(); } GraphicsCard *newGraphicsCard() { return new AsusGraphicsCard(); } PowerSupply *newPowerSupply() { return new AsusPowerSupply(); } }; class LenovoFactory : public Factory { public: Matherboard *newMatherboard() { return new LenovoMatherboard(); } GraphicsCard *newGraphicsCard() { return new LenovoGraphicsCard(); } PowerSupply *newPowerSupply() { return new LenovoPowerSupply(); } }; int main() { Factory *asus = new AsusFactory(); Factory *lenovo = new LenovoFactory(); Matherboard *asusMatherboard = asus-\u0026gt;newMatherboard(); GraphicsCard *asusGraphicsCard = asus-\u0026gt;newGraphicsCard(); PowerSupply *asusPowerSupply = asus-\u0026gt;newPowerSupply(); Matherboard *lenovoMatherboard = lenovo-\u0026gt;newMatherboard(); GraphicsCard *lenovoGraphicsCard = lenovo-\u0026gt;newGraphicsCard(); PowerSupply *lenovoPowerSupply = lenovo-\u0026gt;newPowerSupply(); asusMatherboard-\u0026gt;show(); asusGraphicsCard-\u0026gt;show(); asusPowerSupply-\u0026gt;show(); lenovoMatherboard-\u0026gt;show(); lenovoGraphicsCard-\u0026gt;show(); lenovoPowerSupply-\u0026gt;show(); return 0; } 优缺点 多了一层抽象，减少了工厂的数量 难以扩展产品族，如这里要增加显示器产品的话那么我们要修改Factory、AsusFactory和lenovo这三个类的代码了 ","date":"2023-01-12T00:00:00Z","permalink":"https://moefulye.github.io/p/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","title":"工厂模式"},{"content":"定义 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n使用多个小型工厂一步步构建出一个复杂对象\n类图 classDiagram class Director { +Constructor(builder: Builder) } class Builder { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +buildPart1()* +buildPart2()* +build()*Product } class ConcreteBuilder { +buildPart1() +buildPart2() +build():Product } class Product Director o--\u003e Builder ConcreteBuilder ..|\u003e Builder ConcreteBuilder ..\u003e Product Director 提供构建算法 c++实现 一个简单实现 使用链式调用非传统实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Computer { private: string _cpu; string _ram; string _hdd; string _gpu; string _ssd; public: class ComputerBuilder { private: Computer *_computer; public: ComputerBuilder(string cpu, string ram) { _computer = new Computer(cpu, ram); } ComputerBuilder \u0026amp;set_hdd(string hdd) { _computer-\u0026gt;set_hdd(hdd); return *this; } ComputerBuilder \u0026amp;set_gpu(string gpu) { _computer-\u0026gt;set_gpu(gpu); return *this; } ComputerBuilder \u0026amp;set_ssd(string ssd) { _computer-\u0026gt;set_ssd(ssd); return *this; } Computer *build() { return _computer; } }; Computer(string cpu, string ram) : _hdd(\u0026#34;\u0026#34;), _gpu(\u0026#34;\u0026#34;), _ssd(\u0026#34;\u0026#34;) { _cpu = cpu; _ram = ram; } string cpu() { return _cpu; } string ram() { return _ram; } string hdd() { return _hdd; } string gpu() { return _gpu; } string ssd() { return _ssd; } void set_cpu(string cpu) { _cpu = cpu; } void set_ram(string ram) { _ram = ram; } void set_hdd(string hdd) { _hdd = hdd; } void set_gpu(string gpu) { _gpu = gpu; } void set_ssd(string ssd) { _ssd = ssd; } void show() { cout \u0026lt;\u0026lt; \u0026#34;CPU: \u0026#34; \u0026lt;\u0026lt; _cpu \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;RAM: \u0026#34; \u0026lt;\u0026lt; _ram \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;HDD: \u0026#34; \u0026lt;\u0026lt; _hdd \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;GPU: \u0026#34; \u0026lt;\u0026lt; _gpu \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;SSD: \u0026#34; \u0026lt;\u0026lt; _ssd \u0026lt;\u0026lt; endl; } }; int main() { Computer *pc = Computer::ComputerBuilder(\u0026#34;i7\u0026#34;, \u0026#34;16GB\u0026#34;) .set_gpu(\u0026#34;GTX 1080\u0026#34;) .set_ssd(\u0026#34;512GB\u0026#34;) .build(); pc-\u0026gt;show(); return 0; } 使用Director的传统实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Computer { private: string _cpu; string _ram; string _hdd; string _gpu; string _ssd; public: Computer(string cpu, string ram) : _hdd(\u0026#34;\u0026#34;), _gpu(\u0026#34;\u0026#34;), _ssd(\u0026#34;\u0026#34;) { _cpu = cpu; _ram = ram; } string cpu() { return _cpu; } string ram() { return _ram; } string hdd() { return _hdd; } string gpu() { return _gpu; } string ssd() { return _ssd; } void set_cpu(string cpu) { _cpu = cpu; } void set_ram(string ram) { _ram = ram; } void set_hdd(string hdd) { _hdd = hdd; } void set_gpu(string gpu) { _gpu = gpu; } void set_ssd(string ssd) { _ssd = ssd; } void show() { cout \u0026lt;\u0026lt; \u0026#34;CPU: \u0026#34; \u0026lt;\u0026lt; _cpu \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;RAM: \u0026#34; \u0026lt;\u0026lt; _ram \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;HDD: \u0026#34; \u0026lt;\u0026lt; _hdd \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;GPU: \u0026#34; \u0026lt;\u0026lt; _gpu \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;SSD: \u0026#34; \u0026lt;\u0026lt; _ssd \u0026lt;\u0026lt; endl; } }; class Builder { public: virtual void build_cpu(){}; virtual void build_ram(){}; virtual void build_hdd(){}; virtual void build_gpu(){}; virtual void build_ssd(){}; virtual Computer *build() { return nullptr; }; }; class MacbookBuilder : public Builder { private: Computer *_computer; public: MacbookBuilder(string cpu, string ram) { _computer = new Computer(cpu, ram); } void build_cpu() override { _computer-\u0026gt;set_cpu(\u0026#34;m1\u0026#34;); } void build_ram() override { _computer-\u0026gt;set_ram(\u0026#34;16GB\u0026#34;); } void build_hdd() override { _computer-\u0026gt;set_hdd(\u0026#34;1TB\u0026#34;); } void build_gpu() override { _computer-\u0026gt;set_gpu(\u0026#34;m1\u0026#34;); } void build_ssd() override { _computer-\u0026gt;set_ssd(\u0026#34;512GB\u0026#34;); } Computer *build() override { return _computer; } }; class LenovoBuilder : public Builder { private: Computer *_computer; public: LenovoBuilder(string cpu, string ram) { _computer = new Computer(cpu, ram); } void build_cpu() override { _computer-\u0026gt;set_cpu(\u0026#34;i7\u0026#34;); } void build_ram() override { _computer-\u0026gt;set_ram(\u0026#34;8GB\u0026#34;); } void build_hdd() override { _computer-\u0026gt;set_hdd(\u0026#34;1TB\u0026#34;); } void build_gpu() override { _computer-\u0026gt;set_gpu(\u0026#34;Nvidia\u0026#34;); } void build_ssd() override { _computer-\u0026gt;set_ssd(\u0026#34;256GB\u0026#34;); } Computer *build() override { return _computer; } }; class Director { public: Computer *make(Builder *builder) { builder-\u0026gt;build_cpu(); builder-\u0026gt;build_ram(); builder-\u0026gt;build_hdd(); builder-\u0026gt;build_gpu(); builder-\u0026gt;build_ssd(); return builder-\u0026gt;build(); } }; int main() { Director director; MacbookBuilder macbook_builder(\u0026#34;i5\u0026#34;, \u0026#34;8GB\u0026#34;); LenovoBuilder lenovo_builder(\u0026#34;i7\u0026#34;, \u0026#34;16GB\u0026#34;); Computer *macbook = director.make(\u0026amp;macbook_builder); Computer *lenovo = director.make(\u0026amp;lenovo_builder); macbook-\u0026gt;show(); cout \u0026lt;\u0026lt; endl; lenovo-\u0026gt;show(); return 0; } 效果 它使你可以改变一个产品的内部表示 它将构造代码和表示代码分开 它使你可对构造过程进行更精细的控制 例子 StringBuilder类\n","date":"2023-01-12T00:00:00Z","permalink":"https://moefulye.github.io/p/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/","title":"生成器模式"},{"content":"类的关系 flowchart LR 关系 --接口与类之间--\u003e实现关系 a( ) 关系 -- 对象与对象之间 --\u003e a b(\"泛化关系（is a）\") a --\u003e b a ---\u003e f(关联关系) c(\"聚合关系(has a)\") d(\"组合关系(contains a)\") e(\"依赖关系(use a)\") f --\u003e c f --\u003e d f --\u003e e 实现关系 Implementation 例 A类实现了XXX接口\n继承关系 Inheritance 例 班长类是学生类的派生子类。\n则班长类的一个实例对象 is a 学生类的实例对象\n关联关系 Association 简单的来说即一个对象或者类方法中持有另一个对象的引用、指针或对象本身\n关联关系有单向关联和双向关联。如果两个对象都知道（即可以调用）对方的公共属性和操作，那么二者就是双向关联。如果只有一个对象知道（即可以调用）另一个对象的公共属性和操作，那么就是单向关联。 多重关联一个对象可以持有其它对象的数组或者集合。\n依赖关系 Dependency 如一个司机类的对象A调用开车方法需要一个汽车的引用B作为参数。那么说司机对象use a汽车对象。\n弱关联关系。如果对象A用到对象B，但是和B的关系不是太明显的时候，就可以把这种关系看作是依赖关系。\n依赖关系在Java中的具体代码表现形式为B为A的构造器或方法中的局部变量、方法或构造器的参数、方法的返回值，或者A调用B的静态方法。\n聚合关系 Aggregation A对象持有B对象的所有权，但不一定是单一所有权。\n例如，公司部门与员工的关系，一个员工可以属于多个部门，一个部门撤消了，员工可以转到其它部门。即部门对象 has 员工对象\n组合关系 Composition A对象持有B对象的单一所有权。A的生命周期覆盖B的生命周期。那么A contains B\nUML类图表示法 具体类 访问权限修饰符 + public - private # protected 不加修饰符默认为default 静态成员表示 静态成员用下划线表示\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Dog { private final String name; protect final int weight; public static final int static_member = 1; int age; public void speak(){ /* *code snippets */ } public String getName(){ return this.name; } public void setName(String name) { this.name = name; } public static void foo(){} } uml classDiagram class Dog{ -String name #int weight int age +int static_member$ +speak() +getName() String +setName(name: String) +foo()$ } 抽象修饰符 抽象方法和抽象类用斜体表示\njava 1 2 3 4 public abstract class Base { int member; public abstract void foo(); } uml 注: mermaid里的抽象类用 \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt;表示\nclassDiagram class Base { \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; int member +foo()* } 接口、枚举 接口用\u0026lt;\u0026lt;interface\u0026gt;\u0026gt;表示，枚举用\u0026lt;\u0026lt;enumeration\u0026gt;\u0026gt;表示\numl classDiagram class Shape{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; noOfVertices draw() } class Color{ \u0026lt;\u0026lt;enumeration\u0026gt;\u0026gt; RED BLUE GREEN WHITE BLACK } 泛型 uml classDiagram class Square~Shape~{ int id List~int~ position setPoints(List~int~ points) getPoints() List~int~ } Square : -List~string~ messages Square : +setMessages(List~string~ messages) Square : +getMessages() List~string~ 类的关系表示法 继承 classDiagram A --|\u003e B : A继承自B 实现 classDiagram A ..|\u003e B :A实现了B接口 关联 单向关联 classDiagram A --\u003e B :A知道B 双向关联 classDiagram A \u003c--\u003e B :AB互相知道对方 多重关联 在UML中，通过放置多重性（multipicity）表达式在关联线的末端来表示。多重性表达式可以是一个数字、一段范围或者是它们的组合。\n数字：精确的数量 *或者0..*：表示0到多个 0..1：表示0或者1个，在Java中经常用一个空引用来实现 1..*：表示1到多个 classDiagram Class \"1\" --\u003e \"0..**\" Student :一个班有n个学生 依赖 classDiagram A ..\u003e B : A依赖B 聚合 classDiagram B \u003c--o A :A有B 组合 classDiagram B \u003c--* A : B是A的一部分 ","date":"2023-01-08T00:00:00Z","permalink":"https://moefulye.github.io/p/uml%E7%B1%BB%E5%9B%BE%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB/","title":"uml类图与类的关系"},{"content":"六大设计准则 单一职责原则 开闭原则 依赖倒置原则 接口隔离原则 最少知识原则 二十三设计模式 flowchart LR 设计模式 --\u003e 构建型 设计模式 --\u003e 结构型 设计模式 --\u003e 行为型 构建型 --\u003e 工厂 工厂 --\u003e 简单/静态工厂 工厂 --\u003e 工厂方法 工厂 --\u003e 抽象工厂 构建型 --\u003e 单例 构建型 --\u003e 原型 构建型 --\u003e 生成器模式 结构型 --\u003e 适配器 结构型 --\u003e 桥接 结构型 --\u003e 组合 结构型 --\u003e 装饰 结构型 --\u003e 外观 结构型 --\u003e 享元 结构型 --\u003e 代理 行为型 --\u003e 责任链 行为型 --\u003e 命令 行为型 --\u003e 解释器 行为型 --\u003e 迭代器 行为型 --\u003e 中介者 行为型 --\u003e 备忘录 行为型 --\u003e 观察者 行为型 --\u003e 状态 行为型 --\u003e 策略 行为型 --\u003e 模板方法 行为型 --\u003e 访问者 构建型 [[生成器模式]] [[工厂模式]] [[单例模式]] [[原型模式]] 结构型模式 [[适配器模式]] [[桥接模式]] [[组合模式]] [[装饰器模式]] [[外观模式]] [[享元模式]] [[代理模式]] 行为型 [[责任链模式]] [[命令模式]] [[迭代器模式]] [[解释器模式]] [[中介者模式]] [[备忘录模式]] [[观察者模式]] [[状态模式]] [[策略模式]] [[模板方法]] [[访问者模式]] 参考资料 设计模式可复用面对对象软件的基础 refactoringguru 廖雪峰java程序设计设计模式 ","date":"2023-01-08T00:00:00Z","permalink":"https://moefulye.github.io/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"设计模式"},{"content":"三个基本特征 封装 Encapsulation 继承 Inheritance 多态 Polymorphism 关键词 重载 重写 接口 抽象类 [[类的关系与UML类图]] [[设计模式]] ","date":"2023-01-08T00:00:00Z","permalink":"https://moefulye.github.io/p/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/","title":"面对对象"},{"content":"Hello World 成功公式 $编程= 爱 \\times 狂想 \\times 红色\\times 躬行$\n1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main(int argc, char** argv) { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } ","date":"2023-01-07T16:26:19+08:00","permalink":"https://moefulye.github.io/p/hello-world/","title":"Hello World"}]